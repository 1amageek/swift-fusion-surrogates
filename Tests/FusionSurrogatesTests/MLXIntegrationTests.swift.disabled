import Testing
import MLX
import PythonKit
@testable import FusionSurrogates

/// MLX integration tests - requires MLX and fusion_surrogates
/// Run with: swift test --filter MLXIntegrationTests
@Suite("MLX Integration Tests")
struct MLXIntegrationTests {

    @Test("MLXArray basic operations")
    func mlxArrayBasics() {
        let array = MLXArray([1.0, 2.0, 3.0], [3])
        #expect(array.shape == [3])

        let result = array + MLXArray(1.0)
        eval(result)
        let values = result.asArray(Float.self)
        #expect(values == [2.0, 3.0, 4.0])
    }

    @Test("MLXArray slicing for gradient")
    func mlxSlicing() {
        let array = MLXArray([0.0, 1.0, 2.0, 3.0, 4.0], [5])

        // Test forward slicing
        let forward = array[1 ..< 5]
        eval(forward)
        #expect(forward.shape == [4])
        #expect(forward.asArray(Float.self) == [1.0, 2.0, 3.0, 4.0])

        // Test backward slicing
        let backward = array[0 ..< 4]
        eval(backward)
        #expect(backward.shape == [4])
        #expect(backward.asArray(Float.self) == [0.0, 1.0, 2.0, 3.0])
    }

    @Test("Shape validation with valid inputs")
    func shapeValidationValid() throws {
        let validInput: [String: MLXArray] = [
            "R_L_Te": MLXArray([1.0, 2.0, 3.0], [3]),
            "R_L_Ti": MLXArray([1.0, 2.0, 3.0], [3]),
            "R_L_ne": MLXArray([1.0, 2.0, 3.0], [3]),
            "R_L_ni": MLXArray([1.0, 2.0, 3.0], [3]),
            "q": MLXArray([2.0, 2.0, 2.0], [3]),
            "s_hat": MLXArray([0.5, 0.5, 0.5], [3]),
            "r_R": MLXArray([0.3, 0.3, 0.3], [3]),
            "Ti_Te": MLXArray([1.0, 1.0, 1.0], [3]),
            "log_nu_star": MLXArray([-10.0, -10.0, -10.0], [3]),
            "ni_ne": MLXArray([1.0, 1.0, 1.0], [3])
        ]

        try QLKNN.validateShapes(validInput)
        print("✅ Shape validation passed")
    }

    @Test("Shape validation with mismatched shapes")
    func shapeValidationMismatch() {
        let mismatchedInput: [String: MLXArray] = [
            "R_L_Te": MLXArray([1.0, 2.0, 3.0], [3]),
            "R_L_Ti": MLXArray([1.0, 2.0], [2])  // Different shape!
        ]

        #expect(throws: FusionSurrogatesError.self) {
            try QLKNN.validateShapes(mismatchedInput)
        }
    }

    @Test("Shape validation detects NaN")
    func shapeValidationNaN() {
        let nanInput: [String: MLXArray] = [
            "R_L_Te": MLXArray([1.0, Float.nan, 3.0], [3]),
            "R_L_Ti": MLXArray([1.0, 2.0, 3.0], [3])
        ]

        #expect(throws: FusionSurrogatesError.self) {
            try QLKNN.validateShapes(nanInput)
        }
    }

    @Test("Shape validation detects Inf")
    func shapeValidationInf() {
        let infInput: [String: MLXArray] = [
            "R_L_Te": MLXArray([1.0, Float.infinity, 3.0], [3]),
            "R_L_Ti": MLXArray([1.0, 2.0, 3.0], [3])
        ]

        #expect(throws: FusionSurrogatesError.self) {
            try QLKNN.validateShapes(infInput)
        }
    }

    @Test("Grid size validation - too small")
    func gridSizeTooSmall() {
        let tooSmallInput: [String: MLXArray] = [
            "R_L_Te": MLXArray([1.0], [1]),  // Only 1 cell
            "R_L_Ti": MLXArray([1.0], [1])
        ]

        #expect(throws: FusionSurrogatesError.self) {
            try QLKNN.validateShapes(tooSmallInput)
        }
    }

    @Test("Combine fluxes")
    func combineFluxes() {
        let qlknnOutputs: [String: MLXArray] = [
            "chi_ion_itg": MLXArray([1.0, 2.0, 3.0], [3]),
            "chi_electron_tem": MLXArray([0.5, 1.0, 1.5], [3]),
            "chi_electron_etg": MLXArray([0.3, 0.6, 0.9], [3]),
            "particle_flux": MLXArray([0.1, 0.2, 0.3], [3])
        ]

        let combined = TORAXIntegration.combineFluxes(qlknnOutputs)

        #expect(combined["chi_ion"] != nil)
        #expect(combined["chi_electron"] != nil)
        #expect(combined["particle_diffusivity"] != nil)
        #expect(combined["convection_velocity"] != nil)

        // Check chi_electron = chi_tem + chi_etg
        let chiElectron = combined["chi_electron"]!
        eval(chiElectron)
        let values = chiElectron.asArray(Float.self)
        #expect(abs(values[0] - 0.8) < 1e-5)  // 0.5 + 0.3
        #expect(abs(values[1] - 1.6) < 1e-5)  // 1.0 + 0.6
        #expect(abs(values[2] - 2.4) < 1e-5)  // 1.5 + 0.9
    }

    @Test("Normalized gradient computation")
    func normalizedGradient() {
        // Linear profile: T = 1000 + 1000*r
        let r = MLXArray([0.0, 0.5, 1.0, 1.5, 2.0], [5])
        let T = MLXArray([1000.0, 1500.0, 2000.0, 2500.0, 3000.0], [5])
        let R: Float = 6.2

        let rLnT = TORAXIntegration.computeNormalizedGradient(
            profile: T,
            radius: r,
            majorRadius: R
        )

        eval(rLnT)
        let values = rLnT.asArray(Float.self)

        print("Normalized gradient:", values)

        // For linear profile: dT/dr = 1000
        // R/L_T = -R * (dT/dr) / T = -6.2 * 1000 / T
        // Should be finite and negative
        for value in values {
            #expect(!value.isNaN, "NaN in normalized gradient")
            #expect(!value.isInfinite, "Infinite in normalized gradient")
            #expect(value < 0, "Expected negative gradient")
        }
    }

    @Test("QLKNN buildInputs completeness")
    func buildInputsCompleteness() {
        let n = 5
        let Te = MLXArray([1000.0, 2000.0, 3000.0, 4000.0, 5000.0], [n])
        let Ti = MLXArray([1000.0, 2000.0, 3000.0, 4000.0, 5000.0], [n])
        let ne = MLXArray([1e19, 2e19, 3e19, 4e19, 5e19], [n])
        let psi = MLXArray([0.0, 0.1, 0.2, 0.3, 0.4], [n])
        let r = MLXArray([0.0, 0.5, 1.0, 1.5, 2.0], [n])

        let inputs = QLKNN.buildInputs(
            electronTemperature: Te,
            ionTemperature: Ti,
            electronDensity: ne,
            ionDensity: ne,
            poloidalFlux: psi,
            radius: r,
            majorRadius: 6.2,
            minorRadius: 2.0,
            toroidalField: 5.3
        )

        // Check all required parameters are present
        for paramName in QLKNN.inputParameterNames {
            #expect(inputs[paramName] != nil, "Missing parameter: \(paramName)")
        }

        // Check all have correct shape
        for (key, value) in inputs {
            #expect(value.shape == [n], "Wrong shape for \(key)")
        }

        // Validate that inputs pass validation
        try? QLKNN.validateInputs(inputs)
        try? QLKNN.validateShapes(inputs)
    }

    @Test("MLX prediction with QLKNN")
    func mlxPrediction() throws {
        let qlknn = try QLKNN(modelVersion: "7_11")

        let n = 3
        let inputs: [String: MLXArray] = [
            "R_L_Te": MLXArray([5.0, 5.5, 6.0], [n]),
            "R_L_Ti": MLXArray([5.0, 5.5, 6.0], [n]),
            "R_L_ne": MLXArray([1.0, 1.2, 1.4], [n]),
            "R_L_ni": MLXArray([1.0, 1.2, 1.4], [n]),
            "q": MLXArray([2.0, 2.5, 3.0], [n]),
            "s_hat": MLXArray([1.0, 1.2, 1.4], [n]),
            "r_R": MLXArray([0.3, 0.35, 0.4], [n]),
            "Ti_Te": MLXArray([1.0, 1.0, 1.0], [n]),
            "log_nu_star": MLXArray([-10.0, -9.5, -9.0], [n]),
            "ni_ne": MLXArray([1.0, 1.0, 1.0], [n])
        ]

        let outputs = try qlknn.predict(inputs)

        // Verify outputs have correct shape
        for (key, value) in outputs {
            #expect(value.shape[0] == n, "Output \(key) has wrong shape")
            print("\(key) shape:", value.shape)
        }

        // Check for expected output keys
        #expect(outputs["chi_ion_itg"] != nil)
        #expect(outputs["chi_electron_tem"] != nil)
        #expect(outputs["chi_electron_etg"] != nil)

        print("✅ MLX prediction successful")
    }
}
